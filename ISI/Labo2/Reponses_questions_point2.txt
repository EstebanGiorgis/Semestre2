2.1) c=10, n=1 ==> c^n = 10^1 = 10 ==> ~2^3.4

2.2) c=10, n=2 ==> 10^2 = 100 ==> ~2^6.7

2.3) 10^6 = 1'000'000 ==> ~2^20

2.4) 10^0 + 10^1 + ... + 10^6 = ~1'111'111 = ~2^20

2.5) c=(26 + 10), n=1 ==> 36^1= ~2^5

2.6) n=8 ==> 36^8 = ~2^41.3

2.7)36^0 + 36^1 + ... + 36^8 = (serie arithmetrique) 9 * (36^0 + 36^8)/2 = ~2^43.5

2.8) c= 26 + 26 + 10, n = 1 ==> 62^1 = 62 ==> ~2^6

2.9) 62^8 = ~2^48

2.10) 62^0 + 62^1 + ... + 62^8 = (série arithmétique) 9 * (62^0 + 62^8)/2 = ~2^48

2.11) 2^7


2.12) (2^7)^8 = 2^56

2.13) (2^7)^0 + (2^7)^1 + ... + (2^7)^8 = ~2^56



2.14) 2^41 = ~24h ==> 24/2 = 12 ==> 12h


2.15) 2^56 * 24 / 2^41 = 2^15h

2.16) 2^14 

2.17)
- Hasher les mots de passes
- ajouter un sel
- 



 Limiter les tentatives, après X tentatives chaque tentative suivant raté demandera un temps d'attente avant de pouvoir à nouveau essayer un mot de passe, le temps d'attente augmente de manière exponentielle.

Implémenter un système de double authentification avec une validation par téléphone par exemple, c'est-à-dire qu'une fois avoir entré le bon de passe, il faut ensuite entrer un code, à X chiffres/lettre, généré aléatoirement, qui est envoyé par message à un numéro de téléphone. Il y a de même un certain temps pour inscrit le message avant qu'il soit expiré, donc qui ne soit plus valide pour passer cette seconde étape d'authentification.  




2.19) Les mots  de passes ne sont pas stockés en clair, car dans le cas où un attaquant arriverait à accéder à la base de données qui contiendrait tous les mots de passes, l'attaquant aurait accès à ceux-ci "gratuitement/sans effort" et donc avoir accès à tous les comptes de la base de données.


2.20)


2.21) 









